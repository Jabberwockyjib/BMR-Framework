BMR-TOOL-CONTRACTS.md

Tool Execution Interface Specification (v1.0)

⸻

1. Purpose

This document defines the formal interface contracts for all tools executed within the BMR framework.

Tools include:
	•	machine learning models
	•	physics-based simulations
	•	database and knowledge queries
	•	optimization and analysis routines

Tools are pure execution units. They do not reason, decide, or orchestrate.

⸻

2. Core Principles
	1.	Deterministic when possible
Non-determinism must be declared explicitly.
	2.	Manifest-driven execution
Tools are invoked only via immutable manifests.
	3.	No side effects
Tools may not mutate external state.
	4.	Cost and runtime visibility
Estimated and actual cost must be reported.

⸻

3. Universal Tool Contract

Every tool must implement the following interface:

{
  "tool_name": "string",
  "tool_type": "ml | simulation | database | optimization | analysis",
  "version": "semver",
  "input_schema": {},
  "output_schema": {},
  "estimated_cost_usd": 0.0,
  "estimated_runtime_sec": 0,
  "determinism": "deterministic | stochastic",
  "side_effects": "none",
  "failure_modes": ["string"]
}


⸻

4. Execution Manifest

All tool invocations are driven by an Execution Manifest generated by agents and validated by the Orchestration Kernel.

{
  "execution_id": "uuid",
  "tool_name": "string",
  "tool_version": "semver",
  "inputs": {},
  "requested_by": "agent_role",
  "random_seed": 12345,
  "resource_class": "cpu | gpu | hpc",
  "priority": "low | normal | high"
}


⸻

5. Machine Learning Tool Contracts

5.1 Prediction Tools

Example: ml_predict_property

{
  "inputs": {
    "composition": {},
    "descriptors": {},
    "model_id": "string"
  },
  "outputs": {
    "prediction": "float",
    "uncertainty": "float"
  }
}

Requirements:
	•	uncertainty is mandatory
	•	model version and training data hash logged
	•	extrapolation flags returned if applicable

⸻

5.2 Training / Update Tools

Example: ml_train_surrogate

{
  "inputs": {
    "training_data": "artifact_id",
    "model_config": {}
  },
  "outputs": {
    "model_id": "string",
    "performance_metrics": {},
    "calibration_report": {}
  }
}


⸻

6. Simulation Tool Contracts

6.1 DFT / Atomistic Simulation

Example: simulate_dft

{
  "inputs": {
    "structure": "artifact_id",
    "settings": {},
    "convergence_criteria": {}
  },
  "outputs": {
    "formation_energy": "float",
    "derived_properties": {},
    "converged": true
  }
}

Requirements:
	•	convergence status required
	•	failed convergence must be explicit
	•	retries only for infrastructure failures

⸻

6.2 Mesoscale / Micromagnetics

Example: simulate_micromagnetics

{
  "inputs": {
    "microstructure_model": "artifact_id",
    "field_conditions": {},
    "temperature": "float"
  },
  "outputs": {
    "coercivity": "float",
    "hysteresis_metrics": {},
    "simulation_stable": true
  }
}


⸻

7. Database & Knowledge Tools

7.1 Query Tools

Example: query_materials_database

{
  "inputs": {
    "query": "string",
    "filters": {}
  },
  "outputs": {
    "records": ["artifact_id"],
    "source": "database_name"
  }
}


⸻

8. Optimization Tools

Example: bayesian_optimize

{
  "inputs": {
    "objective_function": "artifact_id",
    "constraints": {},
    "search_space": {},
    "budget": "int"
  },
  "outputs": {
    "recommended_points": [{}],
    "expected_improvement": {}
  }
}


⸻

9. Runner Enforcement Rules

The Runner must:
	•	validate manifests against schemas
	•	log start/end timestamps
	•	capture stdout/stderr
	•	preserve partial outputs on failure
	•	reconcile estimated vs actual cost

The Runner must refuse execution if:
	•	schema validation fails
	•	approval gates are not satisfied

⸻

10. Versioning & Deprecation
	•	tool versions follow semantic versioning
	•	deprecated tools may not be invoked by default
	•	manifests record exact tool versions

⸻

11. Security Assumptions
	•	tools run in sandboxed environments
	•	no external network access unless explicitly allowed
	•	credentials managed by the platform, not agents

⸻

12. Exit Criteria (v1)

Tool Contracts v1 are complete when:
	•	all core workflows can execute using compliant tools
	•	cost and runtime accounting is accurate
	•	failures are handled deterministically

⸻

End of BMR-TOOL-CONTRACTS.md